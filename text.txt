#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
int a, b[10][10], min = 0, x[10][10], num = 0, i = 0;
//x数组相当于bool数组，记录该方格是不是被走过 
//num记录走的步数
//i记录走的路线
//min记录路线最
void lemon(int q, int p)
{
	if (q == a - 2 && p == a - 2)//函数如果到达了终点，则记录其走过的长度 
	{
		if (i == 0)//记录第一次走到终点路线的长度，将他赋值给min。 
		{
			min = num;
		}
		if (num < min)//和走到终点的长度与min来对比 
		{
			min = num;
		}
		i++;//走到终点路线条数 
		return;
	}
	//下面是移动方位控制 
	if (b[q][p] == 0 && x[q][p] == 0)//往上走 
	{
		num++;//记录走过的步数 
		x[q][p] = 1;//将走过的方位标记一下，防止下一次移动重复。 
		lemon(q + 1, p);//往上走 
		//如果运行到这里，说明前面所走的路都不通或者已经走到终点退回来，这时候就将所走的方位标记重置，并且走过的步数会减1 
		x[q][p] = 0;//将这次方位标记 
		num--;
	}
	if (b[q][p] == 0 && x[q][p] == 0)//往下走 
	{
		num++;//记录走过的步数 
		x[q][p] = 1;//将走过的方位标记一下，防止下一次移动重复。 
		lemon(q - 1, p);//往上走 
		//如果运行到这里，说明前面所走的路都不通或者已经走到终点退回来，这时候所走的方位标记就会重置，并且走过的步数会减1 
		x[q][p] = 0;//把这次方位标记下来
		num--;
	}
	if (b[q][p] == 0 && x[q][p] == 0)//往右走 
	{
		num++;//记录走过的步数 
		x[q][p] = 1;//将走过的方位标记，防止下一次移动重复。 
		lemon(q, p + 1);//往上走 
		//如果运行到这里，说明前面所走的路都不通或者已经走到终点退回来，这时候就将所走的方位标记重置，并且走过的步数会减1 
		x[q][p] = 0;//将这次方位标记 
		num--;
	}
	if (b[q][p] == 0 && x[q][p] == 0)//往左边走 
	{
		num++;//记录走过的步数 
		x[q][p] = 1;//走过的方位标记，防止下一次移动重复。 
		lemon(q, p - 1);//往上走 
		//假如运行到这里，说明前面所走的路都不通或者已经走到终点退回来了，这时候就会将所走的方位标记重置，并且走过的步数会减1 
		x[q][p] = 0;//将这次方位标记 
		num--;
	}
}
int main()
{
	scanf("%d", &a);//输入迷宫的长度 
	for (int c = 0; c < a; c++)//构造迷宫的图形 
	{
		for (int d = 0; d < a; d++)
		{
			scanf("%d", &b[c][d]);
		}
	}
	lemon(1, 1);//入口坐标传给函数 
	if (min) //假如min值依然为0，这说明一直都没找到出口，输出No solution，如果min大于0，就说明已经找到最短路线，则输出。 
		printf("%d", min);
	else
		printf
		("No solution");
}